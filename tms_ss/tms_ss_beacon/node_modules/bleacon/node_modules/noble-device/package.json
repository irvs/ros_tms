{
  "name": "noble-device",
  "version": "1.4.1",
  "description": "A Node.js lib to abstract BLE (Bluetooth Low Energy) peripherals, uses noble",
  "main": "index.js",
  "scripts": {
    "pretest": "jshint *.js lib/. examples/.",
    "test": "mocha -R spec test/."
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/sandeepmistry/noble-device.git"
  },
  "keywords": [
    "noble",
    "BLE",
    "Bluetooth Low Energy",
    "Bluetooth Smart",
    "Bluetooth 4.0"
  ],
  "author": {
    "name": "Sandeep Mistry",
    "email": "sandeep.mistry@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/sandeepmistry/noble-device/issues"
  },
  "homepage": "https://github.com/sandeepmistry/noble-device",
  "devDependencies": {
    "jshint": "~2.4.4",
    "mocha": "~1.17.1",
    "should": "~3.1.3",
    "async": "~0.7.0"
  },
  "dependencies": {
    "noble": "^1.7.0"
  },
  "readme": "noble-device\n============\n\nA Node.js lib to abstract BLE (Bluetooth Low Energy) peripherals, using [noble](https://github.com/sandeepmistry/noble)\n\n## Install\n```\nnpm install noble-device\n```\n\n## Usage\n\nTake a look at the [Tethercell](https://github.com/sandeepmistry/node-tethercell/) and [unofficial LightBlue Bean](https://github.com/jacobrosenthal/ble-bean) devices for examples, but this is how you make a basic device:\n\n```javascript\nvar NobleDevice = require('noble-device');\n\nvar YOUR_THING_SERVICE_UUID = 'xxxxxxxxxxxxxxxxxxxxxxxx';\nvar YOUR_THING_NOTIFY_CHAR  = 'xxxxxxxxxxxxxxxxxxxxxxxx';\nvar YOUR_THING_READ_CHAR    = 'xxxxxxxxxxxxxxxxxxxxxxxx';\nvar YOUR_THING_WRITE_CHAR   = 'xxxxxxxxxxxxxxxxxxxxxxxx';\n\n// then create your thing with the object pattern\nvar YourThing = function(peripheral) {\n  // call nobles super constructor\n  NobleDevice.call(this, peripheral);\n\n  // setup or do anything else your module needs here\n};\n\n// tell Noble about the service uuid(s) your peripheral advertises (optional)\nYourThing.SCAN_UUIDS = [YOUR_THING_SERVICE_UUID];\n\n// and/or specify method to check peripheral (optional)\nYourThing.is = function(peripheral) {\n  return (peripheral.advertisement.localName === 'My Thing\\'s Name');\n};\n\n// inherit noble device\nNobleDevice.Util.inherits(YourThing, NobleDevice);\n\n// you can mixin other existing service classes here too,\n// noble device provides battery and device information,\n// add the ones your device provides\nNobleDevice.Util.mixin(YourThing, NobleDevice.BatteryService);\nNobleDevice.Util.mixin(YourThing, NobleDevice.DeviceInformationService);\n\n// export your device\nmodule.exports = YourThing;\n```\n\nNow to use `YourThing` you must use one of the discover functions [documented below](#discovery-api) which will find your device(s) and pass instances of your object to their callback where you must call `connectAndSetUp`.\n\n```javascript\nvar YourThing = require('YourThing');\n\nvar id = '<your devices id>';\nYourThing.discoverById(function(yourThingInstance) {\n\n  // you can be notified of disconnects\n  yourThingInstance.on('disconnect', function() {\n    console.log('we got disconnected! :( ');\n  });\n\n  // you'll need to call connect and set up\n  yourThingInstance.connectAndSetUp(function(error) {\n    console.log('were connected!');\n  });\n\n});\n```\n\nIt doesn't do much yet, let's go back and add to our Device definition (right before ``module.exports``)\n\n```javascript\n// you could send some data\nYourThing.prototype.send = function(data, done) {\n  this.writeDataCharacteristic(YOUR_THING_SERVICE_UUID, YOUR_THING_WRITE_CHAR, data, done);\n};\n\n// read some data\nYourThing.prototype.receive = function(callback) {\n  this.readDataCharacteristic(YOUR_THING_SERVICE_UUID, YOUR_THING_READ_CHAR, callback);\n};\n```\n\n\nNow in our connect and setup we can:\n\n```javascript\n    yourThing.send(new Buffer([0x00, 0x01]), function() {\n      console.log('data sent');\n    });\n\n    yourThing.receive(function(error, data) {\n      console.log('got data: ' + data);\n    });\n```\n\nOptionally, if you need to do some device setup or close something down before disconnect, you can override those functions:\n\n```javascript\nYourThing.prototype.connectAndSetup = function(callback) {\n  NobleDevice.prototype.connectAndSetup.call(this, function(error) {\n    // maybe notify on a characteristic ?\n    this.notifyCharacteristic(YOUR_THING_SERVICE_UUID, YOUR_THING_NOTIFY_CHAR, true, this._onRead.bind(this), function(err) {\n      callback(err);\n    });\n  }.bind(this);\n};\n\nYourThing.prototype.onDisconnect = function() {\n  // clean up ...\n\n  // call super's onDisconnect\n  NobleDevice.prototype.onDisconnect.call(this);\n};\n```\n\n\n### Discovery API\n\n__Discover All__\n\n``` javascript\nfunction onDiscover(yourThingInstance) {\n  // called for all devices discovered\n}\n\nYourThing.discoverAll(onDiscover);\n```\n\n__Stopping a Discover All__\n\n```javascript\n\nYourThing.stopDiscoverAll(onDiscover);\n```\n\n__Discover a single device__\n\n``` javascript\nYourThing.discover(function(yourThingInstance) {\n  // called for only the first device discovered\n});\n```\n\n__Stopping a Discover__\n\n```javascript\n\nYourThing.stopDiscover(onDiscoverCallback);\n```\n\n__Discover with Filter__\n\n``` javascript\nYourThing.discoverWithFilter(function(device), {\n  // filter callback for device,\n  //   return true to stop discovering and choose device\n  //   return false to continue discovery\n\n  return true; // or false\n}, function(yourThingInstance) {\n  // called for only one device discovered that matches filter\n});\n```\n\n__Discover by ID__\n\n``` javascript\nvar id = \" ... \"; // id of device we want to discover\n\nYourThing.discoverById(id, function(yourThingInstance) {\n  // called for only one device discovered\n});\n```\n\n",
  "readmeFilename": "README.md",
  "_id": "noble-device@1.4.1",
  "_from": "noble-device@^1.1.0"
}
